MERGE SORT VISUAL REPRESENTATION
================================

Sorting array: [38, 27, 43, 3, 9, 82, 10]

DIVIDE PHASE (Top-Down):
========================

Level 0: Original Array
┌────┬────┬────┬────┬────┬────┬────┐
│ 38 │ 27 │ 43 │ 3  │ 9  │ 82 │ 10 │
└────┴────┴────┴────┴────┴────┴────┘
                 │
                 ▼ SPLIT
        ┌────────┴────────┐

Level 1: Split into two halves
┌────┬────┬────┐           ┌────┬────┬────┬────┐
│ 38 │ 27 │ 43 │           │ 3  │ 9  │ 82 │ 10 │
└────┴────┴────┘           └────┴────┴────┴────┘
        │                           │
        ▼ SPLIT                     ▼ SPLIT
   ┌────┴────┐               ┌─────┴─────┐

Level 2: Split again
┌────┬────┐ ┌────┐     ┌────┬────┐ ┌────┬────┐
│ 38 │ 27 │ │ 43 │     │ 3  │ 9  │ │ 82 │ 10 │
└────┴────┘ └────┘     └────┴────┘ └────┴────┘
     │        │             │           │
     ▼ SPLIT  │             ▼ SPLIT     ▼ SPLIT
  ┌──┴──┐     │          ┌──┴──┐    ┌───┴───┐

Level 3: Individual elements (base case)
┌────┐┌────┐┌────┐    ┌────┐┌────┐┌────┐┌────┐
│ 38 ││ 27 ││ 43 │    │ 3  ││ 9  ││ 82 ││ 10 │
└────┘└────┘└────┘    └────┘└────┘└────┘└────┘

CONQUER PHASE (Bottom-Up Merge):
================================

Level 3 → Level 2: Merge pairs
┌────┐┌────┐         ┌────┐┌────┐         ┌────┐┌────┐
│ 38 ││ 27 │  MERGE  │ 3  ││ 9  │  MERGE  │ 82 ││ 10 │
└────┘└────┘    ↓    └────┘└────┘    ↓    └────┘└────┘

Compare & Merge:
38 vs 27 → 27 first    3 vs 9 → 3 first     82 vs 10 → 10 first
┌────┬────┐           ┌────┬────┐           ┌────┬────┐
│ 27 │ 38 │           │ 3  │ 9  │           │ 10 │ 82 │
└────┴────┘           └────┴────┘           └────┴────┘

Level 2 → Level 1: Merge larger subarrays
┌────┬────┐ ┌────┐              ┌────┬────┐ ┌────┬────┐
│ 27 │ 38 │ │ 43 │    MERGE     │ 3  │ 9  │ │ 10 │ 82 │
└────┴────┘ └────┘       ↓      └────┴────┘ └────┴────┘

Detailed merge of [27,38] and [43]:
Step 1: Compare 27 vs 43 → 27 smaller
┌────┬────┬────┐
│ 27 │    │    │
└────┴────┴────┘

Step 2: Compare 38 vs 43 → 38 smaller
┌────┬────┬────┐
│ 27 │ 38 │    │
└────┴────┴────┘

Step 3: Add remaining 43
┌────┬────┬────┐
│ 27 │ 38 │ 43 │
└────┴────┴────┘

Detailed merge of [3,9] and [10,82]:
Step 1: Compare 3 vs 10 → 3 smaller
┌────┬────┬────┬────┐
│ 3  │    │    │    │
└────┴────┴────┴────┘

Step 2: Compare 9 vs 10 → 9 smaller
┌────┬────┬────┬────┐
│ 3  │ 9  │    │    │
└────┴────┴────┴────┘

Step 3: Add remaining [10,82]
┌────┬────┬────┬────┐
│ 3  │ 9  │ 10 │ 82 │
└────┴────┴────┴────┘

Level 1 → Level 0: Final merge
┌────┬────┬────┐              ┌────┬────┬────┬────┐
│ 27 │ 38 │ 43 │    MERGE     │ 3  │ 9  │ 10 │ 82 │
└────┴────┴────┘       →      └────┴────┴────┴────┘

FINAL MERGE PROCESS:
===================

Left:  [27, 38, 43]    Right: [3, 9, 10, 82]
       ↑                      ↑
      i=0                    j=0

Step 1: Compare 27 vs 3 → 3 smaller
Result: [3, _, _, _, _, _, _]
Left:  [27, 38, 43]    Right: [3, 9, 10, 82]
       ↑                         ↑
      i=0                       j=1

Step 2: Compare 27 vs 9 → 9 smaller
Result: [3, 9, _, _, _, _, _]
Left:  [27, 38, 43]    Right: [3, 9, 10, 82]
       ↑                            ↑
      i=0                          j=2

Step 3: Compare 27 vs 10 → 10 smaller
Result: [3, 9, 10, _, _, _, _]
Left:  [27, 38, 43]    Right: [3, 9, 10, 82]
       ↑                               ↑
      i=0                             j=3

Step 4: Compare 27 vs 82 → 27 smaller
Result: [3, 9, 10, 27, _, _, _]
Left:  [27, 38, 43]    Right: [3, 9, 10, 82]
          ↑                            ↑
         i=1                          j=3

Step 5: Compare 38 vs 82 → 38 smaller
Result: [3, 9, 10, 27, 38, _, _]
Left:  [27, 38, 43]    Right: [3, 9, 10, 82]
             ↑                         ↑
            i=2                       j=3

Step 6: Compare 43 vs 82 → 43 smaller
Result: [3, 9, 10, 27, 38, 43, _]
Left:  [27, 38, 43]    Right: [3, 9, 10, 82]
                ↑                      ↑
            i=3 (end)                 j=3

Step 7: Copy remaining from right
Result: [3, 9, 10, 27, 38, 43, 82]

FINAL SORTED ARRAY:
┌────┬────┬────┬────┬────┬────┬────┐
│ 3  │ 9  │ 10 │ 27 │ 38 │ 43 │ 82 │  ✓ SORTED!
└────┴────┴────┴────┴────┴────┴────┘

RECURSION TREE VISUALIZATION:
=============================

                    [38,27,43,3,9,82,10]
                           │
                    ┌──────┴──────┐
                    │             │
              [38,27,43]      [3,9,82,10]
                 │                │
            ┌────┴────┐      ┌────┴────┐
            │         │      │         │
        [38,27]     [43]   [3,9]    [82,10]
           │         │      │         │
       ┌───┴───┐     │  ┌───┴───┐ ┌───┴───┐
       │       │     │  │       │ │       │
     [38]    [27]   [43][3]    [9][82]   [10]
       │       │     │  │       │ │       │
       └───┬───┘     │  └───┬───┘ └───┬───┘
           │         │      │         │
        [27,38]     [43]   [3,9]   [10,82]
           │         │      │         │
           └────┬────┘      └────┬────┘
                │                │
           [27,38,43]      [3,9,10,82]
                │                │
                └────────┬───────┘
                         │
                [3,9,10,27,38,43,82]

ALGORITHM FLOWCHART:
===================

┌─────────────┐
│   START     │
└─────┬───────┘
      │
      ▼
┌─────────────┐
│ Array size  │    Yes
│    <= 1?    ├────────┐
└─────┬───────┘        │
      │ No             │
      ▼                │
┌─────────────┐        │
│ Find middle │        │
│ mid = n/2   │        │
└─────┬───────┘        │
      │                │
      ▼                │
┌─────────────┐        │
│ Recursively │        │
│ sort LEFT   │        │
│ half        │        │
└─────┬───────┘        │
      │                │
      ▼                │
┌─────────────┐        │
│ Recursively │        │
│ sort RIGHT  │        │
│ half        │        │
└─────┬───────┘        │
      │                │
      ▼                │
┌─────────────┐        │
│ MERGE two   │        │
│ sorted      │        │
│ halves      │        │
└─────┬───────┘        │
      │                │
      └────────────────┤
                       │
                       ▼
                ┌─────────────┐
                │   RETURN    │
                │   ARRAY     │
                └─────────────┘

MERGE ALGORITHM DETAIL:
======================

┌─────────────┐
│ Initialize  │
│ i=0, j=0,   │
│ k=0         │
└─────┬───────┘
      │
      ▼
┌─────────────┐    No
│ i<left_size │────────┐
│ && j<right_ │        │
│ size?       │        │
└─────┬───────┘        │
      │ Yes            │
      ▼                │
┌─────────────┐        │
│left[i] <=   │  Yes   │
│right[j]?    ├────┐   │
└─────┬───────┘    │   │
      │ No         │   │
      ▼            │   │
┌─────────────┐    │   │
│result[k] =  │    │   │
│right[j]     │    │   │
│j++, k++     │    │   │
└─────┬───────┘    │   │
      │            │   │
      └────────────┼───┤
                   │   │
            ┌─────────────┐
            │result[k] =  │
            │left[i]      │
            │i++, k++     │
            └─────┬───────┘
                  │
                  └───────────┘
                              │
                              ▼
                       ┌─────────────┐
                       │ Copy        │
                       │ remaining   │
                       │ elements    │
                       └─────────────┘

COMPLEXITY ANALYSIS:
===================

Time Complexity: O(n log n)
• Divide: O(log n) levels
• Conquer: O(n) work per level
• Total: O(n) × O(log n) = O(n log n)

Space Complexity: O(n)
• Temporary arrays for merging
• Recursion stack: O(log n)
• Total: O(n)

Best Case: O(n log n)
Average Case: O(n log n)
Worst Case: O(n log n)

STABLE SORT: ✓ (maintains relative order of equal elements)
IN-PLACE: ✗ (requires additional space)

RECURRENCE RELATION:
T(n) = 2T(n/2) + O(n)
By Master Theorem: T(n) = O(n log n)
